package com.library.service;import com.library.domain.Author;import com.library.domain.Book;import com.library.domain.BookTag;import com.library.repository.BooksRepository;import org.hibernate.PersistentObjectException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.dao.DataIntegrityViolationException;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import javax.validation.ConstraintViolationException;import java.util.List;import java.util.Optional;import java.util.stream.Collectors;import java.util.stream.Stream;@Servicepublic class BookService {    @Autowired    BooksRepository booksRepository;    @Autowired    AuthorService authorService;    @Autowired    BookTagService bookTagService;    public List<Book> getAllBooks(Pageable pageable) {        //Sort.Direction.fromString(sortDir), sort        Page<Book> bookPage = booksRepository.findAll(pageable);        return bookPage.getContent();    }    public long getCount() {        return booksRepository.count();    }    public Book saveBook(final Book book) {        List<Author>listAuthors = book.getAuthors().stream()                .collect(Collectors.toList());        List<BookTag>listBookTags = book.getBookTags().stream()                .collect(Collectors.toList());        try {            Stream.iterate(0, i  -> i + 1).                    limit(listAuthors.size())                    .forEach( (i) -> {                        listAuthors.get(i);                        Optional<Author> authorOptional = authorService.findAuthorByName(book.getAuthors().get(i).getForename(),                                listAuthors.get(i).getSurname());                        if (authorOptional.isPresent()) {                            book.getAuthors().set(i, authorOptional.get());                        }                    });            Stream.iterate(0, i -> i + 1)                    .limit(listBookTags.size())                    .forEach( (i) -> {                        Optional<BookTag> bookTagOptional = bookTagService.findBookTagByName(book.getBookTags().get(i).getLiteraryGenre());                        if (bookTagOptional.isPresent()) {                            book.getBookTags().set(i, bookTagOptional.get());                        }                    });            booksRepository.save(book);        } catch (DataIntegrityViolationException dE) {            System.out.println("Entry already exist");        } catch (PersistentObjectException pE) {            System.out.println("Author already exist, but has added entry to join Table ");        }        catch(ConstraintViolationException cve) {           cve.getMessage();        }        return book;    }    public Optional<Book> getBook(final Long id) {        return booksRepository.findById(id);    }    public void deleteBook(final Long id) {        booksRepository.deleteById(id);    }    public Optional<Book>findBookBySignature(String signature) {        return booksRepository.findBySignature(signature);    }    public List<Book>getBooksWithSpecifiedTitle(String title) {        List<Book>books = booksRepository.findByTitle(title);        if(books.size() > 0) {           List<String>titles = books.stream().map(book -> book.getTitle()).collect(Collectors.toList());           System.out.println(titles);        }      return books;    }}