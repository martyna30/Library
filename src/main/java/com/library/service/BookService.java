package com.library.service;import com.library.domain.*;import com.library.domain.bn.TypeOfObject;import com.library.exception.BookNotFoundException;import com.library.exception.ObjectNameNotFoundException;import com.library.repository.BooksRepository;import com.sun.xml.bind.v2.runtime.unmarshaller.XsiNilLoader;import org.hibernate.PersistentObjectException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.dao.DataIntegrityViolationException;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import javax.validation.ConstraintViolationException;import java.io.InvalidClassException;import java.time.LocalDate;import java.time.LocalDateTime;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Optional;import java.util.stream.Collectors;import java.util.stream.Stream;@Servicepublic class BookService {    @Autowired    BooksRepository booksRepository;    @Autowired    AuthorService authorService;    @Autowired    BookTagService bookTagService;    @Autowired    ObjectService objectService;    public List<Book> getAllBooks(Pageable pageable) {        //Sort.Direction.fromString(sortDir), sort        Page<Book> bookPage = booksRepository.findAll(pageable);        return bookPage.getContent();    }    public long getCount() {        return booksRepository.count();    }    public Book saveBook(final Book book) throws InvalidClassException {        List<Author> listAuthors = book.getAuthors().stream()                .collect(Collectors.toList());        List<BookTag> listBookTags = book.getBookTags().stream()                .collect(Collectors.toList());        try {            Stream.iterate(0, i -> i + 1).                    limit(listAuthors.size())                    .forEach((i) -> {                        listAuthors.get(i);                        Optional<Author> authorOptional = authorService.findAuthorByName(                                book.getAuthors().get(i).getForename(),                                listAuthors.get(i).getSurname()                        );                        if (authorOptional.isPresent()) {                            book.getAuthors().set(i, authorOptional.get());                            try {                                ObjectName objectNameAuthor = new ObjectName(listAuthors.get(i));                                objectNameAuthor.setId(authorOptional.get().getId());                                Optional<ObjectName> optionalObjectNameAuthor = objectService.findObjectWithSpecifiedTitleOrAuthor(                                        objectNameAuthor.getName());                                if (!optionalObjectNameAuthor.isPresent()) {                                    objectService.save(objectNameAuthor);                                }                            } catch (InvalidClassException e) {                                throw new RuntimeException(e);                            }                        }                        if (!authorOptional.isPresent()) {                            try {                                ObjectName objectNameAuthor = new ObjectName(listAuthors.get(i));                                objectNameAuthor.setId(listAuthors.get(i).getId());                                Optional<ObjectName> optionalObjectNameAuthor = objectService.findObjectWithSpecifiedTitleOrAuthor(                                        objectNameAuthor.getName());                                if (!optionalObjectNameAuthor.isPresent()) {                                    objectService.save(objectNameAuthor);                                }                            } catch (InvalidClassException e) {                                throw new RuntimeException(e);                            }                        }                    });            Stream.iterate(0, i -> i + 1)                    .limit(listBookTags.size())                    .forEach((i) -> {                        Optional<BookTag> bookTagOptional = bookTagService.findBookTagByName(book.getBookTags().get(i).getLiteraryGenre());                        if (bookTagOptional.isPresent()) {                            book.getBookTags().set(i, bookTagOptional.get());                        }                    });            ObjectName objectNameBook = new ObjectName(book);            objectNameBook.setId(book.getId());            Optional<ObjectName> optionalObjectNameBook = objectService.findObjectWithSpecifiedTitleOrAuthor(objectNameBook.getName());            if (!optionalObjectNameBook.isPresent()) {                objectService.save(objectNameBook);            }            booksRepository.save(book);        } catch (DataIntegrityViolationException dE) {            System.out.println("Entry already exist");        } catch (PersistentObjectException pE) {            System.out.println("Author already exist, but has added entry to join Table ");        } catch (InvalidClassException exception) {            System.out.println(exception.getMessage());        } catch (ConstraintViolationException cve) {            cve.getMessage();        }        return book;    }    public Optional<Book> getBook(final Long id) {        return booksRepository.findById(id);    }    public void deleteBook(final Long id) {        booksRepository.deleteById(id);    }    public Optional<Book> findBookBySignature(String signature) {        return booksRepository.findBySignature(signature);    }    public List<Book> getBooksWithSpecifiedTitle(String title) {        List<Book> books = booksRepository.findByTitle(title);        if (books.size() > 0) {            List<String> titles = books.stream().map(book -> book.getTitle()).collect(Collectors.toList());            System.out.println(titles);        }        return books;    }}