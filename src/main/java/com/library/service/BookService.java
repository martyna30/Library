package com.library.service;import com.library.domain.*;import com.library.domain.bn.TypeOfObject;import com.library.exception.BookNotFoundException;import com.library.exception.ObjectNameNotFoundException;import com.library.repository.BooksRepository;import com.sun.xml.bind.v2.runtime.unmarshaller.XsiNilLoader;import org.hibernate.PersistentObjectException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.dao.DataIntegrityViolationException;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.stereotype.Service;import javax.transaction.Transactional;import javax.validation.ConstraintViolationException;import java.io.InvalidClassException;import java.time.LocalDate;import java.time.LocalDateTime;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Optional;import java.util.stream.Collectors;import java.util.stream.IntStream;import java.util.stream.LongStream;import java.util.stream.Stream;@Servicepublic class BookService {    @Autowired    BooksRepository booksRepository;    @Autowired    AuthorService authorService;    @Autowired    BookTagService bookTagService;    @Autowired    ObjectService objectService;    @Autowired    RentalService rentalService;    public List<Book> getAllBooks(Pageable pageable) {        Page<Book> bookPage = booksRepository.findAll(pageable);        return bookPage.getContent();    }    public long getCount() {        return booksRepository.count();    }    //@Transactional    public Book saveBook(final Book book) throws InvalidClassException {        List<Author> listAuthors = book.getAuthors().stream()                .collect(Collectors.toList());        List<BookTag> listBookTags = book.getBookTags().stream()                .collect(Collectors.toList());        try {            if (listAuthors.size() > 0) {                Stream.iterate(0, i -> i + 1).                        limit(listAuthors.size())                        .forEach((i) -> {                            listAuthors.get(i);                            Optional<Author> authorOptional = authorService.findAuthorByName(                                    book.getAuthors().get(i).getForename(),                                    listAuthors.get(i).getSurname()                            );                            if (authorOptional.isPresent()) {                                book.getAuthors().set(i, authorOptional.get());                                Optional<ObjectName> optionalObjectNameAuthor = objectService.findObjectWithSpecifiedTitleOrAuthor(                                        authorOptional.get().getSurname());                                if (optionalObjectNameAuthor.isPresent()) {                                    book.getAuthors().get(i).getObjectNameAuthor().setId(optionalObjectNameAuthor.get().getId());                                } else {                                    StringBuilder forename = new StringBuilder(book.getAuthors().get(i).getForename());                                    StringBuilder surname = new StringBuilder(listAuthors.get(i).getSurname());                                    StringBuilder names = forename.append(surname);                                    String name = names.toString();                                    ObjectName objectNameAuthor = null;                                    try {                                        objectNameAuthor = new ObjectName(name,authorOptional.get());                                    } catch (InvalidClassException e) {                                        throw new RuntimeException(e);                                    }                                    authorOptional.get().setObjectNameAuthor(objectNameAuthor);                                }                            }                        });            }            Stream.iterate(0, i -> i + 1)                    .limit(listBookTags.size())                    .forEach((i) -> {                        Optional<BookTag> bookTagOptional = bookTagService.findBookTagByName(book.getBookTags().get(i).getLiteraryGenre());                        if (bookTagOptional.isPresent()) {                            book.getBookTags().set(i, bookTagOptional.get());                        }                    });            Optional<ObjectName> optionalObjectNameBook = objectService.findObjectWithSpecifiedTitleOrAuthor(book.getTitle());            if (optionalObjectNameBook.isPresent()) {                optionalObjectNameBook.get().setId(optionalObjectNameBook.get().getId());                book.setObjectName(optionalObjectNameBook.get());            } else {                ObjectName objectNameBook = new ObjectName(book.getTitle(), book);                book.setObjectName(objectNameBook);                objectService.save(objectNameBook);            }            booksRepository.save(book);        }             catch(DataIntegrityViolationException dE){                System.out.println("Entry already exist");            } catch(PersistentObjectException pE){                System.out.println("Author already exist, but has added entry to join Table ");            } catch(ConstraintViolationException cve){                cve.getMessage();            } catch (InvalidClassException e) {            throw new RuntimeException(e);        }        return book;        }    public Optional<Book> getBook(final Long id) {        return booksRepository.findById(id);    }    public void deleteBook(final Long id) {        booksRepository.deleteById(id);    }    public Optional<Book> findBookBySignature(String signature) {        return booksRepository.findBySignature(signature);    }    public List<Book> getBooksWithSpecifiedTitle(String title) {        List<Book> books = booksRepository.findByTitle(title);        if (books.size() > 0) {            List<String> titles = books.stream().map(book -> book.getTitle()).collect(Collectors.toList());            System.out.println(titles);        }        return books;    }}